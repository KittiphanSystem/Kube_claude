package tenant

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// TenantConfig ข้อมูลทั้งหมดสำหรับ generate bootstrap
type TenantConfig struct {
	TenantName string
	PlanName   string
	Plan       Plan
	RepoURL    string
	Domain     string
	Email      string
	BillingID  string
	CreatedAt  string
}

// NewTenantConfig สร้าง config จาก input
func NewTenantConfig(name, planName, repo, domain, email string) (*TenantConfig, error) {
	plan, err := GetPlan(planName)
	if err != nil {
		return nil, err
	}

	billingID := fmt.Sprintf("bill-%s-%d", name, time.Now().Unix())

	return &TenantConfig{
		TenantName: name,
		PlanName:   planName,
		Plan:       plan,
		RepoURL:    repo,
		Domain:     domain,
		Email:      email,
		BillingID:  billingID,
		CreatedAt:  time.Now().UTC().Format(time.RFC3339),
	}, nil
}

// RenderAllTemplates สร้างไฟล์ bootstrap ทั้งหมดสำหรับ tenant
func RenderAllTemplates(cfg *TenantConfig, outputDir string) error {
	bootstrapDir := filepath.Join(outputDir, "bootstrap")
	if err := os.MkdirAll(bootstrapDir, 0755); err != nil {
		return fmt.Errorf("สร้าง bootstrap dir ไม่ได้: %w", err)
	}

	files := map[string]string{
		"namespace.yaml":       namespaceTemplate,
		"rbac.yaml":            rbacTemplate,
		"quota.yaml":          quotaTemplate,
		"limitrange.yaml":     limitrangeTemplate,
		"networkpolicy.yaml":  networkpolicyTemplate,
		"argocd.yaml":         argocdTemplate,
		"ingress.yaml":        ingressTemplate,
	}

	for filename, tmplStr := range files {
		outPath := filepath.Join(bootstrapDir, filename)
		if err := renderTemplate(tmplStr, outPath, cfg); err != nil {
			return fmt.Errorf("render %s ล้มเหลว: %w", filename, err)
		}
	}

	// สร้าง tenant.yaml descriptor
	if err := renderTemplate(tenantDescriptorTemplate, filepath.Join(outputDir, "tenant.yaml"), cfg); err != nil {
		return fmt.Errorf("render tenant.yaml ล้มเหลว: %w", err)
	}

	return nil
}

// renderTemplate render template string ลงไฟล์
func renderTemplate(tmplStr, outPath string, data interface{}) error {
	funcMap := template.FuncMap{
		"upper": strings.ToUpper,
		"lower": strings.ToLower,
	}

	tmpl, err := template.New(filepath.Base(outPath)).Funcs(funcMap).Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("parse template ล้มเหลว: %w", err)
	}

	f, err := os.Create(outPath)
	if err != nil {
		return fmt.Errorf("สร้างไฟล์ %s ไม่ได้: %w", outPath, err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("execute template ล้มเหลว: %w", err)
	}

	return nil
}

// ============================================================
// TEMPLATES
// ============================================================

var namespaceTemplate = `# Auto-generated by blueprintctl — DO NOT EDIT MANUALLY
# Edit tenant.yaml and run: blueprintctl tenant sync --name {{.TenantName}}
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-{{.TenantName}}
  labels:
    tenant: "{{.TenantName}}"
    plan: "{{.PlanName}}"
    kube-saas/tenant: "{{.TenantName}}"
    kube-saas/plan: "{{.PlanName}}"
    kube-saas/billing-id: "{{.BillingID}}"
  annotations:
    kube-saas/created-at: "{{.CreatedAt}}"
    kube-saas/contact-email: "{{.Email}}"
    kube-saas/domain: "{{.Domain}}"
`

var rbacTemplate = `# Auto-generated by blueprintctl
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: tenant-viewer
  namespace: tenant-{{.TenantName}}
rules:
  - apiGroups: [""]
    resources: ["pods", "pods/log", "services", "configmaps", "events", "endpoints"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets", "replicasets", "daemonsets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: tenant-deployer
  namespace: tenant-{{.TenantName}}
rules:
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets"]
    verbs: ["get", "list", "watch", "update", "patch"]
  - apiGroups: [""]
    resources: ["configmaps", "secrets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  - apiGroups: [""]
    resources: ["pods", "pods/log", "services", "events", "endpoints"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tenant-viewers-binding
  namespace: tenant-{{.TenantName}}
subjects:
  - kind: Group
    name: tenant-{{.TenantName}}-viewers
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: tenant-viewer
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tenant-deployers-binding
  namespace: tenant-{{.TenantName}}
subjects:
  - kind: Group
    name: tenant-{{.TenantName}}-deployers
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: tenant-deployer
  apiGroup: rbac.authorization.k8s.io
---
# Allow tenant-portal ServiceAccount to read pods in this namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tenant-portal-reader-binding
  namespace: tenant-{{.TenantName}}
subjects:
  - kind: ServiceAccount
    name: tenant-portal-sa
    namespace: devtroncd
roleRef:
  kind: ClusterRole
  name: tenant-portal-reader
  apiGroup: rbac.authorization.k8s.io
`

var quotaTemplate = `# Auto-generated by blueprintctl
apiVersion: v1
kind: ResourceQuota
metadata:
  name: tenant-{{.TenantName}}-quota
  namespace: tenant-{{.TenantName}}
  labels:
    kube-saas/tenant: "{{.TenantName}}"
    kube-saas/plan: "{{.PlanName}}"
spec:
  hard:
    requests.cpu: "{{.Plan.CPURequests}}"
    limits.cpu: "{{.Plan.CPULimits}}"
    requests.memory: {{.Plan.MemRequests}}
    limits.memory: {{.Plan.MemLimits}}
    pods: "{{.Plan.MaxPods}}"
    persistentvolumeclaims: "{{.Plan.MaxPVC}}"
    requests.storage: {{.Plan.MaxStorage}}
    services: "10"
    services.loadbalancers: "0"
    services.nodeports: "0"
    secrets: "50"
    configmaps: "50"
`

var limitrangeTemplate = `# Auto-generated by blueprintctl
apiVersion: v1
kind: LimitRange
metadata:
  name: tenant-{{.TenantName}}-limits
  namespace: tenant-{{.TenantName}}
  labels:
    kube-saas/tenant: "{{.TenantName}}"
spec:
  limits:
    - type: Container
      default:
        cpu: {{.Plan.DefaultCPULimit}}
        memory: {{.Plan.DefaultMemLimit}}
      defaultRequest:
        cpu: {{.Plan.DefaultCPURequest}}
        memory: {{.Plan.DefaultMemRequest}}
      max:
        cpu: "{{.Plan.MaxCPUPerContainer}}"
        memory: {{.Plan.MaxMemPerContainer}}
      min:
        cpu: "10m"
        memory: "16Mi"
    - type: Pod
      max:
        cpu: "{{.Plan.MaxCPUPerPod}}"
        memory: {{.Plan.MaxMemPerPod}}
    - type: PersistentVolumeClaim
      max:
        storage: {{.Plan.MaxPVCSize}}
      min:
        storage: "1Gi"
`

var networkpolicyTemplate = `# Auto-generated by blueprintctl
---
# Default deny all
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
---
# Allow DNS (REQUIRED)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Egress
  egress:
    - ports:
        - port: 53
          protocol: UDP
        - port: 53
          protocol: TCP
---
# Allow traffic from tenant ingress controller only
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-ingress
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: ingress-nginx
          podSelector:
            matchLabels:
              app.kubernetes.io/instance: tenant
---
# Allow intra-namespace communication
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-same-namespace
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - podSelector: {}
  egress:
    - to:
        - podSelector: {}
---
# Allow egress to internet (HTTP/HTTPS)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-internet
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Egress
  egress:
    - ports:
        - port: 80
          protocol: TCP
        - port: 443
          protocol: TCP
---
# Allow Prometheus scraping
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-prometheus-scrape
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: monitoring
          podSelector:
            matchLabels:
              app.kubernetes.io/name: prometheus
---
# Allow tenant portal to read pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-tenant-portal
  namespace: tenant-{{.TenantName}}
spec:
  podSelector: {}
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: devtroncd
          podSelector:
            matchLabels:
              app: tenant-portal
`

var argocdTemplate = `# Auto-generated by blueprintctl
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: tenant-{{.TenantName}}
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "5"
    kube-saas/tenant: "{{.TenantName}}"
    kube-saas/plan: "{{.PlanName}}"
spec:
  description: "Tenant {{.TenantName}} — locked to own namespace + repo"
  sourceRepos:
    - {{.RepoURL}}
  destinations:
    - namespace: tenant-{{.TenantName}}
      server: https://kubernetes.default.svc
  clusterResourceWhitelist: []
  namespaceResourceWhitelist:
    - group: "apps"
      kind: Deployment
    - group: "apps"
      kind: StatefulSet
    - group: "apps"
      kind: ReplicaSet
    - group: ""
      kind: Service
    - group: ""
      kind: ConfigMap
    - group: ""
      kind: Secret
    - group: ""
      kind: ServiceAccount
    - group: ""
      kind: PersistentVolumeClaim
    - group: "networking.k8s.io"
      kind: Ingress
    - group: "autoscaling"
      kind: HorizontalPodAutoscaler
    - group: "batch"
      kind: Job
    - group: "batch"
      kind: CronJob
  roles:
    - name: viewer
      description: "Tenant {{.TenantName}} read-only"
      policies:
        - p, proj:tenant-{{.TenantName}}:viewer, applications, get, tenant-{{.TenantName}}/*, allow
      groups:
        - tenant-{{.TenantName}}-viewers
    - name: deployer
      description: "Tenant {{.TenantName}} can sync"
      policies:
        - p, proj:tenant-{{.TenantName}}:deployer, applications, sync, tenant-{{.TenantName}}/*, allow
        - p, proj:tenant-{{.TenantName}}:deployer, applications, get, tenant-{{.TenantName}}/*, allow
        - p, proj:tenant-{{.TenantName}}:deployer, applications, action/*, tenant-{{.TenantName}}/*, allow
      groups:
        - tenant-{{.TenantName}}-deployers
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: tenant-{{.TenantName}}-apps
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "10"
    kube-saas/tenant: "{{.TenantName}}"
spec:
  project: tenant-{{.TenantName}}
  source:
    repoURL: {{.RepoURL}}
    targetRevision: main
    path: environments/prod
  destination:
    server: https://kubernetes.default.svc
    namespace: tenant-{{.TenantName}}
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=false
      - PrunePropagationPolicy=foreground
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
  ignoreDifferences:
    - group: apps
      kind: Deployment
      jsonPointers:
        - /spec/replicas
`

var ingressTemplate = `# Auto-generated by blueprintctl
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tenant-{{.TenantName}}-web
  namespace: tenant-{{.TenantName}}
  labels:
    kube-saas/tenant: "{{.TenantName}}"
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-XSS-Protection "1; mode=block" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-connections: "20"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - {{.Domain}}
      secretName: tenant-{{.TenantName}}-tls
  rules:
    - host: {{.Domain}}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  number: 80
`

var tenantDescriptorTemplate = `# Auto-generated by blueprintctl
# แก้ไขไฟล์นี้แล้วรัน: blueprintctl tenant sync --name {{.TenantName}}
apiVersion: kube-saas/v1
kind: Tenant
metadata:
  name: {{.TenantName}}
  createdAt: "{{.CreatedAt}}"
spec:
  contactEmail: {{.Email}}
  domain: {{.Domain}}
  billingId: {{.BillingID}}
  plan: {{.PlanName}}
  repo:
    url: {{.RepoURL}}
    revision: main
    path: environments/prod
  features:
    monitoring: true
    alerting: true
    portalAccess: true
`
